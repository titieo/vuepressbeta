"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.resolveHeadersFromTokens = void 0;
const shared_1 = require("@vuepress/shared");
/**
 * Resolve headers from markdown-it tokens
 */
const resolveHeadersFromTokens = (tokens, { level, allowHtml, escapeText, slugify, format, }) => {
    // store the result of headers
    const headers = [];
    // a temp headers stack for generating the headers tree
    const stack = [];
    // push a header to the headers tree
    const push = (header) => {
        while (stack.length !== 0 && header.level <= stack[0].level) {
            stack.shift();
        }
        if (stack.length === 0) {
            headers.push(header);
            stack.push(header);
        }
        else {
            stack[0].children.push(header);
            stack.unshift(header);
        }
    };
    tokens.forEach((_, idx) => {
        var _a, _b;
        const token = tokens[idx];
        // if the token type is not matched, skip
        if ((token === null || token === void 0 ? void 0 : token.type) !== 'heading_open') {
            return;
        }
        // get the level from the tag, h1 -> 1
        const headerLevel = Number.parseInt(token.tag.slice(1), 10);
        // if the level should not be extracted, skip
        if (!level.includes(headerLevel)) {
            return;
        }
        // the next token of 'heading_open' contains the heading content
        const nextToken = tokens[idx + 1];
        // if the next token does not exist, skip
        if (!nextToken) {
            return;
        }
        // children of the next token contains the parsed result of the heading title
        const nextTokenChildren = (_a = nextToken.children) !== null && _a !== void 0 ? _a : [];
        // filter tokens for generating heading title
        // 'text' and 'code_inline' should be escaped to avoid being treated as html
        // 'emoji' and 'html_inline' should be used directly
        const titleTokenTypes = ['text', 'emoji', 'code_inline'];
        // include 'html_inline' or not
        if (allowHtml) {
            titleTokenTypes.push('html_inline');
        }
        const titleTokens = nextTokenChildren.filter((item) => titleTokenTypes.includes(item.type));
        // get title from tokens
        const title = titleTokens
            .reduce((result, item) => {
            if (escapeText) {
                // escape the content of 'code_inline' and 'text'
                if (item.type === 'code_inline' || item.type === 'text') {
                    return `${result}${shared_1.htmlEscape(item.content)}`;
                }
            }
            // keep the content of 'emoji' and 'html_inline'
            return `${result}${item.content}`;
        }, '')
            .trim();
        // the id of the heading anchor is the slugify result of markdown-it-anchor
        // if the id does not exist, slugify the title ourselves
        const slug = (_b = token.attrGet('id')) !== null && _b !== void 0 ? _b : slugify(title);
        // push the header to tree
        push({
            level: headerLevel,
            title: shared_1.isFunction(format) ? format(title) : title,
            slug,
            children: [],
        });
    });
    return headers;
};
exports.resolveHeadersFromTokens = resolveHeadersFromTokens;
